library(httr)


get_new_access_token <- function() {
    refresh_token <- readLines("tokens/refresh.token")
    client_id <- readLines("tokens/client_id.token")
    client_secret <- readLines("tokens/client_secret.token")
    
    post_data = list('grant_type' = 'refresh_token',
                     'refresh_token' = refresh_token,
                     'client_id' = client_id,
                     'client_secret' = client_secret)
    
    res <- POST("https://accounts.spotify.com/api/token", body = post_data, encode = "form")
    
    access_token <- content(res)[["access_token"]]
    
    writeLines(access_token, "tokens/access.token")
    return(access_token)
}


link2id <- function(playlist_link) {
    link_split <- strsplit(playlist_link, "/")[[1]]
    return(strsplit(link_split[length(link_split)], "\\?")[[1]][1])
}


parse_tracks <- function(res) {
    #' Parses tracks into a succinct list, given the result 
    #' of a successful request to the playlists API as input
    
    tracks <- lapply(content(res)[["items"]], function(track_chunk) {
        track <- track_chunk[["track"]][c("artists", "duration_ms", "id", "name", "popularity", "preview_url")]
        track[["artists"]] <- c(sapply(track[["artists"]], function(x) x[["name"]]))
        track[["release_date"]] <- track_chunk[["track"]][["album"]][["release_date"]]
        
        return(track)
    })
    
    return(tracks)
}


import_playlist <- function(playlist_link, import_length = 1000, use_cache = TRUE, cache_expiry_days = 90, attempts = 0) {
    access_token <- readLines("tokens/access.token")
    playlist_id <- link2id(playlist_link)
    
    if(is.null(playlist_id) || is.na(playlist_id) || nchar(playlist_id) < 5) {
        stop(sprintf("Invalid playlist ID: %s", playlist_id))
    }
    
    # Check cache for playlist ------------------------------------------------
    #' If the cache hasn't expired, then we will load it and return without
    #' bothering to make a new request to Spotify
    
    file_loc <- sprintf("cache/playlists/%s.cache", playlist_id)
    if(use_cache) {
        if(file.exists(file_loc)) {
            # Check if cache has expired
            cache_age_days <- as.numeric(difftime(Sys.time(), file.info(file_loc)[["mtime"]], units = "days"))
            
            if(cache_age_days < cache_expiry_days) {
                return(readRDS(file_loc))
            }
        }
    }
    
    # Make initial request for playlist ---------------------------------------
    
    res <- GET(sprintf("https://api.spotify.com/v1/playlists/%s/tracks?offset=0", playlist_id), 
               add_headers('Authorization' = sprintf('Bearer %s', access_token)))
    
    if(status_code(res) != 200) {
        print(sprintf("Error importing playlist id %s: %s", playlist_id, content(res)))
        
        if(attempts == 0) {
            print("Could not import playlist; out of attempts")
            return(NULL)
        }
        
        print("Obtaining new access token...")
        access_token <- get_new_access_token()
        return(import_playlist(playlist_link, import_length, use_cache, cache_expiry_days, attempts - 1))
    }
    
    
    # If success, parse tracks and increment offset until max tracks parsed ---
    
    tracks <- parse_tracks(res)
    
    offset <- 100
    while(length(content(res)[["items"]]) == 100 && offset < import_length) {
        
        res <- GET(sprintf("https://api.spotify.com/v1/playlists/%s/tracks?offset=%s", playlist_id, offset), 
                   add_headers('Authorization' = sprintf('Bearer %s', access_token)))
        
        tracks <- c(tracks, parse_tracks(res))
        
        offset <- offset + 100
    }
    
    # Playlist successfully parsed --------------------------------------------
    
    playlist <- list('id' = playlist_id,
                     'tracks' = tracks)
    
    saveRDS(playlist, file_loc)
    
    return(playlist)
}


export_playlist <- function(playlist_name, track_ids) {
    access_token <- readLines("tokens/access.token")
    
    # Create new playlist -----------------------------------------------------
    
    user_id <- '1254892983'  # Blake
    
    post_data <- list('name' = playlist_name,
                      'description' = sprintf('Auto-generated by PlaymakeR on %s', Sys.Date()))
    
    res <- POST(sprintf("https://api.spotify.com/v1/users/%s/playlists", user_id), body = post_data, encode = "json",
                add_headers('Authorization' = sprintf('Bearer %s', access_token)))
    
    if(status_code(res) != 201) {
        stop("Error generating playlist")
    }
    
    playlist_id <- content(res)[["id"]]
    
    # Add items to playlist ---------------------------------------------------
    
    for(i in seq(1, length(track_ids), 100)) {
        uris <- sprintf('spotify:track:%s', track_ids[i:min(i + 99, length(track_ids))])
        
        post_data <- list('position' = i - 1,
                          'uris' = uris)
        
        res <- POST(sprintf("https://api.spotify.com/v1/playlists/%s/tracks", playlist_id), body = post_data, encode = "json",
                    add_headers('Authorization' = sprintf('Bearer %s', access_token)))
    }
    
    if(!(status_code(res) %in% c(200, 201))) {
        stop("Error adding tracks to playlist")
    } else {
        print(sprintf("Playlist: %s successfully created and populated!", playlist_name))
    }
}


get_user_playlists <- function(user_id) {
    access_token <- readLines("tokens/access.token")
    
    offset <- 0
    user_playlists <- c()
    started <- FALSE
    
    while(!started || length(content(res)[["items"]]) == 20) {
        started <- TRUE
        res <- GET(sprintf('https://api.spotify.com/v1/users/%s/playlists?offset=%s&limit=50', user_id, offset), 
                   add_headers('Authorization' = sprintf('Bearer %s', access_token)))
        
        if(status_code(res) != 200) {
            stop("Error getting user's playlists")
        }
        
        user_playlists <- c(user_playlists, sapply(content(res)[["items"]], function(x) x[["href"]]))
        offset <- offset + 50
    }
    
    return(user_playlists)
}



import_user_playlists <- function(user_id, verbose = F) {
    user_playlists <- get_user_playlists(user_id)
    
    if(length(user_playlists) < 50) {  # To keep it more authentic, try not to import users with too many playlists (>= 50)
        playlist_import <- sapply(user_playlists, function(playlist) import_playlist(playlist, use_cache = T, cache_expiry_days = 90)) 
        
        if(verbose) {
            print(sprintf("Imported %s playlists from user: %s", length(user_playlists), user_id))
        }
    }
}


import_other_playlists_from_creator <- function(playlist_id, verbose = F) {
    access_token <- readLines("tokens/access.token")
    
    # Get playlist creator info -----------------------------------------------
    
    res <- GET(sprintf("https://api.spotify.com/v1/playlists/%s", playlist_id), 
               add_headers('Authorization' = sprintf('Bearer %s', access_token)))   
    
    if(status_code(res) == 200) {
        creator_id <- content(res)[["owner"]][["id"]]
        import_user_playlists(creator_id, verbose)
    }
}


playlist2dt <- function(playlist) {
    if(is.null(playlist) || length(playlist[["tracks"]]) == 0) {
        return(NULL)
    }
    
    playlist_dt <- suppressWarnings(rbindlist(lapply(playlist[["tracks"]], function(x) {
        if(is.null(x[["id"]]) || is.null(x[["release_date"]])) {
            return(NULL)
        }
        
        x[["full_name"]] <- sprintf("%s - %s", x[["name"]], paste(x[["artists"]], collapse = ", "))
        x[["artists"]] <- paste(x[["artists"]], collapse = "_!+!_")
        return(x)
    })))
    
    if(nrow(playlist_dt) == 0) {
        return(NULL)
    }
    
    playlist_dt[["artists"]] <- strsplit(playlist_dt[["artists"]], "_!\\+!_")
    playlist_dt[popularity == 0, popularity := as.integer(playlist_dt[popularity > 0, mean(popularity)])]
    
    return(playlist_dt[, -"preview_url"])
}


track2id <- function(track_name) {
    access_token <- readLines("tokens/access.token")
    
    res <- GET(sprintf("https://api.spotify.com/v1/search?q=%s&type=track", gsub(" ", "+", track_name)), 
               add_headers('Authorization' = sprintf('Bearer %s', access_token)))
    
    return(content(res)[["tracks"]][["items"]][[1]][["id"]])
}

